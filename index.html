<!DOCTYPE html>
<html lang="en" dir="ltr">
  <!-- Notes to editors:
          * Set tabs to 2 spaces.
          * Never use tab characters.
          * Remove all trailing white-space from lines.
          * Some vertical white-space is good, too much is bad.
          * Paragraphs should have one sentance per line!
          * Use TODO's very sparingly and always include a link to the relevant issue(s)
            or project task(s).
  -->
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"/>
    <meta name="author" content="Joseph W Donahue" />
    <meta name="description" content="Version Meta spec and web site" />
    <link rel="canonical" href="https://versionmeta.org/" />
    <title>Version Schema {Experimental.0}</title>
  </head>
  <body>
    <!-- TODO {D9707538-3AA2-4E4B-18F3-2F1E4FA677B8}: CSS! -->
    <div id="product-tag">
      <h1>Version Schema</h1>
      <div id="version-tag">
       Version: Experimental.0 {VSchemaInDev.0}</div>
      </div>
    <h2 id="summary">Summary</h2>

    <p>
    VersionSchema is a proposed standard schema for declaring the syntax and semantics of any version string, or (aspirationally) XML, JSON or YAML record containing version data.
    The current focus is on defining version string syntax and semantics.
    A version schema is meant to convey; both human, and machine readable, information regarding the syntax and business rules (semantics), applied to any version data that includes a <a href="https://versionmeta.org/">Version Meta tag</a>. 
    This project is an early work-in-progress and no standard schema has been settled on.
    We have one experimental <a href="versionschema.experimental.0.xsd"> XML schema</a> and some <a href="ExampleSchemas.html">example Version Schema</a> based on that XSD ready for comment.
    Oxygen XML (<a href="http://www.oxygenxml.com/">link</a>) <a href="http://versionschema.org/versionschema.experimental.0.html">docs available here.</a>
    A GitHub project has been setup to <a href="https://github.com/VersionSchema/VersionSchema">track artifacts</a>, <a href="https://github.com/VersionSchema/VersionSchema/projects">progress</a>, and <a href="https://github.com/VersionSchema/VersionSchema/issues">take feedback</a>.
    </p>

    <p>
    The subtitle and browser window/tab title of this page; both contain a URI within curly braces that is a <a href="https://versionmeta.org/">Version Meta tag</a>, that points to the <a href="Schemas/VSchemaInDev.0.xml">version schema in use</a> for versioning the current VersionSchema XSD file. 
    A full description of that schema can be read <a href="Schemas/VSchemaInDev.0.html">here</a>.
    </p>

    <h2 id="introduction">Introduction</h2>

    <p>
    A version schema is any XML file containing only elements defined in the official VersionSchema XSD file.
    The current version under development is <a href="versionschema.experimental.next.xsd">versionschema.experimental.next.xsd</a>. 
    Oxygen XML (<a href="http://www.oxygenxml.com/">link</a>) <a href="http://versionschema.org/versionschema.experimental.next.html">docs available here.</a>
    Tooling to process VersionSchema's is a work-in-progress, but not currently ready for any kind of review.
    </p>

    <h3 id="past_present_and_future">Past Present and Future</h3>

    <p>
    Probably the best known and oldest artifacts that version numbers are applied to, are books.
    Publishers call them revisions, and they have employed variations of at least several schemes; ranging from dates, a single integer (rev 1, rev2, etc), through "decimal" revisions (1, 1.2, etc) to more complicated schemes incorporating digits, letters of the alphabet and other symbols.
    In the realm of computer software, the earliest version schemes often followed whatever scheme the engineering department used to version their circuit board designs and other products.
    </p>

    <p>
    The current best practice for software, is to use <a href="https://semver.org/">SemVer</a>, but few actually use it correctly and most would prefer to have it modified to also accept any one of a dozen variations.
    Part of the problem has to do with the variety of things that must be versioned.
    SemVer is tied, by definition, to API's and any associated packages containing implementations of those API's.
    While nobody can blame the keepers of the SemVer standard for their rightfully narrow focus, the universe contains a much wider array of artifacts that require versioning of one kind or another. 
    In addition, there's a wide range of common practices with regard to the prerelease and build meta tags in use and there is no common method for conveying the semantic details embedded in those practices.
    </p>

    <p>
    VersionSchema represents a possible next step in the evolution of version strings.
    If successful, we will no longer be locked into pseudo-standards that are barely more than least common denominators.
    In the near future, you should be able to use a range of version schemata for different purposes, such as internal test releases, early adopter (flight testing), wider public releases, etc.
    Use one schema for your documents or art work and another for your software.
    In every case, the same set of tooling can be used in your build/publish pipelines, no matter what semantics are applied to the version strings in use.
    </p>

    <h3 id="goals">Goals</h3>

    <ul>
      <li>Human readable description of version string syntax and business rules.</li>
      <li>Machine readable description of version string syntax and business rules.</li>
      <li>Reasonably compact version schema format that can be described in a standard schema language (XSD).</li>
      <li>Allow description of any kind of version string, for any use.</li>
      <li>Simple tooling and libraries, support all schemes.</li>
      <li>Provide a set of version schemes that reflect the top five or ten common practices.</li>
      <li>Not just for software.</li>
      <!--
      <li></li>
      -->
    </ul>

    <h3 id="aspirations">Aspirations</h3>

    <ul>
      <li>Automatic regex generation from version schema.</li>
      <li>Automatic state machine generation from version schema.</li>
      <li>Simple tooling assists developers in generating schemes matching their development models.
        <ul>
          <li>From state machine diagrams.</li>
          <li>Integrated schema editor.</li>
        </ul>
      </li>    
      <li>Automated generation of test oracles.</li>
    </ul>

    <h2>Scenarios</h2>

    <p>
    <a href="https://versionmeta.org/">VersionMeta</a> and <a href="http://versionschema.org/">VersionSchema</a> combined, enable a plurality of scenarios that can be applied individually or in sequence, to support a variety of work-flows across a wide range of organizations.
    We're maintaining a growing <a href="ExampleSchemas.html">set of example schema</a> to highlight features of VesionSchema.
    The following scenarios describe how <a href="https://versionmeta.org/">VersionMeta</a> and <a href="http://versionschema.org/">VersionSchema</a> can be combined for practical use.
    </p>

    <h3>Continuous Integration</h3>

    <p>
    Automated continuous integration is a defining DevOps process.
    Automation produces a build for every submission/merge, to a designated repository, and then publishes a package for internal testing and possibly wider audiences.
    These builds are often not considered to be "official releases", but often do find their way into more or less public feeds.
    It's a common practice for these build products to retain the version number of the previously publically released, or the intended target version, but this leads to many packages with different content that have the same version strings.
    To avoid this, many CI build systems simply append a prerelease tag and build number to the version information.
    If/when QA signs-off on a build product, the prerelease tag is removed and the product is made available on an appropriate public feed.
    </p>

    <p>
    With <a href="https://versionmeta.org/">VersionMeta</a> and <a href="http://versionschema.org/">VersionSchema</a>, you don't have to force-fit any one version scheme to fit every stage of your processes.
    Instead, you have something like our <a href="Examples/Simplecounter.xml">simple build counter schema</a> and your version strings have the form:
    </p>

    <pre>
    # {SimpleCounter}
    </pre>

    <p>
    The undefined assurances declared by this schema indicate that it is potentially unstable and the total form of the version string make it obvious it's not an "official release" of any kind.
    Additionally, an organization could deploy different schema's for flight-test releases, release-candidates and official releases.
    </p>

    <h3>Product Prerelease</h3>

    <p>
    Product prereleases have a wide variety of version string formats.
    They range from one or more integer fields, to strings of tags/identifiers and combinations thereof.
    <a href="https://versionmeta.org/">VersionMeta</a> and <a href="http://versionschema.org/">VersionSchema</a> provide a clear indication of which scheme is in use and any quality or compatibility assurance claims of the publisher.
    </p>

    <p>
    For software components, <a href="https://semver.org/">semantic versioning</a> is one of the more popular version formats in use today.
    It is supported by a variety of tools and well understood in the software development community.
    We have created an <a href="Schemas/SemVer.2.0.0.xml">unofficial first draft</a> schema for <a href="https://semver.org/spec/v2.0.0.html">SemVer 2.0.0</a>.
    A proposed version string might have the form:
    </p>

    <pre>
    #.#.#-prerelease+optional.build.meta {SemVer.2.0.0}
    </pre>

    <h3>Product Release</h3>

    <p>
    Again <a href="https://semver.org/">semantic versioning</a> comes to mind:
    </p>

    <pre>
    #.#.#+optional.build.meta {SemVer.2.0.0}
    </pre>

    <h3>Hybrids</h3>

    <p>
    Given a hypothetical organization X, any number of schema can be deployed across the full variety of publications:
    </p>

    <h4>Website</h4>

    <pre>
    YYYY.MM.DD.HH.MM {UTC.Timestamp}
    </pre>

    <h4>Book</h4>
    
    <pre>
    ########## {ISBN10}
    ############# {ISBN13}
    </pre>

    <h4>GUI</h4>

    <pre>
      #.# {Version.Patch}
    </pre>

    <h4>CI build artifact</h4>

    <pre>
    # {https://X.org/SimpleCounter}
    </pre>

    <small>Last updated 2018-08-29 12:38 UTC</small>

  </body>
</html>
